질문 (원본):
2025-10-28

질문: @# King - 건물주 (Building Owner) 
**학습해** 등록된 일정에서 수정을 누른 후 반복 일정을 체크하면 반복유형 ui가 나온다. 하지만기본값인 매일이 선택되어 있지 않고 빈값으로 나온다.

맨처음 일정을 등록할때 반복일정을 체크 안하고 저장한다음 수정을 눌러서 수정할때 반복일정을 누르면 반복유형이 나올때 기본적으로 매일로 선택되어서 되게 나와야한다.

답변:
건물주로서 수정 모드에서의 기본값 문제를 발견하고 수정했습니다.

## 🔍 문제 발견 및 분석

### 문제 시나리오

1. **일정 등록**: 반복 일정 **체크 안 함** → `repeat.type = 'none'` 저장
   
2. **일정 수정**: 저장된 일정의 "수정" 버튼 클릭
   
3. **`editEvent()` 호출**: `setRepeatType('none')` 실행
   
4. **반복 일정 체크박스 체크**: `isRepeating = true` → 반복 유형 Select 표시
   
5. **문제 발생**: Select 값 = `'none'` 하지만 옵션 = `['daily', 'weekly', 'monthly', 'yearly']`
   
6. **결과**: 빈 값으로 표시됨 ❌

### 근본 원인

**파일**: `src/hooks/useEventForm.ts` Line 68 (수정 전)

```typescript
// ❌ WRONG
const editEvent = (event: Event) => {
  setIsRepeating(event.repeat.type !== 'none');
  setRepeatType(event.repeat.type);  // 'none'을 그대로 설정!
  //             ^^^^^^^^^^^^^^^^^^^^^
  //             Select 옵션에 'none'이 없어서 빈 값 표시
};
```

**문제점**:
- `event.repeat.type`이 `'none'`이면 그대로 상태에 설정
- 사용자가 나중에 반복 일정 체크박스를 체크해도
- `repeatType`은 여전히 `'none'`
- Select 옵션에는 `'none'`이 없음 → **빈 값 표시**

## ✅ 적용한 수정

```68:68:src/hooks/useEventForm.ts
    setRepeatType(event.repeat.type !== 'none' ? event.repeat.type : 'daily');
```

**수정 내용**:
```typescript
// ✅ CORRECT
const editEvent = (event: Event) => {
  setIsRepeating(event.repeat.type !== 'none');
  setRepeatType(event.repeat.type !== 'none' ? event.repeat.type : 'daily');
  //             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  //             'none'이면 기본값 'daily' 사용, 아니면 기존 값 유지
};
```

### 동작 방식

**Case 1**: 반복 유형이 있는 일정 수정 (예: 'weekly')
```
event.repeat.type = 'weekly'
→ 'weekly' !== 'none' ? 'weekly' : 'daily'
→ 'weekly' ✅
→ Select에 '매주' 표시
```

**Case 2**: 반복 없는 일정 수정 (예: 'none')
```
event.repeat.type = 'none'
→ 'none' !== 'none' ? 'none' : 'daily'
→ 'daily' ✅
→ Select에 '매일' 표시 (기본값)
```

## 📚 학습 내용 저장

### 저장 위치
`src/.cursor/agents/home/memoryHome.md` (Line 375-548)

### 핵심 학습: 완전한 기본값 패턴

UI 컴포넌트의 기본값은 **3곳 모두**에서 일관되게 적용되어야 합니다:

#### 1. Initial State (초기 상태)
```typescript
const [repeatType, setRepeatType] = useState<RepeatType>('daily');
```
✅ 컴포넌트 첫 로드 시 기본값

#### 2. Form Reset (폼 리셋)
```typescript
const resetForm = () => {
  setRepeatType('daily');
};
```
✅ 폼 지울 때 기본값으로 복원

#### 3. Edit Mode (수정 모드) ⭐ NEW
```typescript
const editEvent = (event: Event) => {
  setRepeatType(event.repeat.type !== 'none' ? event.repeat.type : 'daily');
};
```
✅ 값이 없는 항목 수정 시 기본값 적용

## 🎯 테스트 체크리스트

수정 후 확인해야 할 5가지 시나리오:

### ✅ 1. Initial Add (초기 추가)
- 새 일정 추가 → 반복 일정 체크
- **예상**: 반복 유형 = '매일' 선택됨

### ✅ 2. Reset (리셋)
- 폼 작성 중 취소/리셋
- **예상**: 반복 유형 = '매일'로 복원

### ✅ 3. Edit with Value (값이 있는 항목 수정)
- 반복 유형 '매주'인 일정 수정
- **예상**: 반복 유형 = '매주' 유지

### ✅ 4. Edit without Value (값이 없는 항목 수정) ⭐ 이번 수정
- 반복 없는 일정 수정 → 반복 일정 체크
- **예상**: 반복 유형 = '매일' 자동 선택

### ✅ 5. Toggle Visibility (가시성 토글)
- 체크박스로 숨겨진 입력 표시
- **예상**: 입력에 유효한 기본값 있음

## 📝 모든 에이전트를 위한 학습

### Planner (계획자)
- [ ] 수정/업데이트 기능 계획 시, 설정되지 않은 값에 대한 기본 동작 명시
- [ ] 모든 경로 고려: 초기 → 리셋 → 수정 → 재수정
- [ ] UI 가시성 토글 시 예상 동작 문서화

### Worker (노동자)
- [ ] 값이 없거나 기본값인 항목의 수정 모드 테스트
- [ ] Select/Dropdown이 항상 옵션과 일치하는 유효한 값을 갖는지 확인
- [ ] 초기 상태, 리셋, 수정 모두 기본값 준수 확인

### Manager (관리자)
- [ ] 수정 함수에서 기본값 처리 검토
- [ ] 조건부 UI가 적절한 기본값을 갖는지 확인
- [ ] Select가 필수 값을 가질 때 빈 값을 표시하지 않는지 확인

## 💡 코드 패턴 요약

```typescript
// 일반 패턴: 외부 데이터에서 상태 설정 시, 유효하지 않은/빈 값 확인
const setValue = (externalValue) => {
  setState(isValidValue(externalValue) ? externalValue : DEFAULT_VALUE);
};

// 실제 적용 예시:
setRepeatType(event.repeat.type !== 'none' ? event.repeat.type : 'daily');
//            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ^^^^^^^^^^^^^^^^^^^^  ^^^^^^^
//            유효한 값인지 확인              기존 값 사용          기본값 사용
```

## 🎊 수정 결과

### Before (수정 전)
```
❌ 반복 없는 일정 수정 → 반복 일정 체크 → 빈 값 표시
❌ 사용자 혼란 및 추가 입력 필요
```

### After (수정 후)
```
✅ 반복 없는 일정 수정 → 반복 일정 체크 → '매일' 자동 선택
✅ 즉시 사용 가능, 필요시 변경
✅ 학습 내용 memoryHome.md에 저장 완료
```

### 성공 지표
**"Select/Dropdown 컴포넌트는 항상 유효한 선택 항목을 표시하며, 특히 수정 후에도 절대 빈 값을 표시하지 않음"**

이제 모든 에이전트가 이 패턴을 참고하여 초기 상태, 리셋, 수정 모드 모두에서 일관되게 기본값을 적용할 수 있습니다! 🚀

