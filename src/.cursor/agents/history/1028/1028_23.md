질문 (원본):
2025-10-28

질문: @# King - 건물주 (Building Owner) 
**학습해**
history 안에 있는 1028_15부터 1028_22까지 확인한 다음 중요한 오류 수정사항을 agents/doc/checklist.md안에 리팩토링해서 추가해라. 다음에 같은 오류가 나오지 않도록 작성해라.

답변:
건물주로서 1028_15부터 1028_22까지의 history 파일을 분석하여 중요한 오류 패턴들을 `checklist.md`에 추가했습니다.

## 📊 분석한 History 파일 (1028_15 ~ 1028_22)

### 1028_15: 반복 일정 테스트 코드 작성
**내용**: TDD 방식으로 `generateRecurringEvents` 함수 구현
- ✅ 16개 테스트 작성 및 통과
- ✅ 매일/매주/매월/매년 반복 모든 패턴 커버
- ✅ 월말 날짜, 윤년 처리 포함

### 1028_16: 구현 vs 통합 격차 (Implementation vs Integration)
**핵심 문제**: ⭐ **구현하고 테스트했지만 UI와 연결 안 함**
```
✅ generateRecurringEvents 함수 구현
✅ 16개 테스트 모두 통과
❌ useEventOperations에서 호출 안 함!
→ 사용자가 반복 일정 등록해도 단일 이벤트만 저장됨
```

**교훈**: 
> 테스트 통과 ≠ 기능 완성  
> 구현 → 테스트 → **통합** → 전체 흐름 검증

### 1028_17: 잘못된 반복 유형 저장
**문제**: UI에서 "매월" 선택했지만 DB에 "weekly"로 저장
**원인**: 서버 포트 충돌 + 수정 전 코드로 등록
**해결**: 서버 재시작 + 이벤트 재등록

### 1028_18: Date 오버플로우 처리 (Month-End Dates)
**핵심 문제**: ⭐ **31일 반복이 월말이 없는 달에 28일/30일로 표시됨**
```
사용자 요구: 31일에만 표시, 없으면 건너뛰기
기존 동작: 2월 28일, 4월 30일로 조정 ❌
```

**해결 전략 변경**:
```typescript
// Before: 오버플로우 후 조정
nextDate.setDate(31);
if (overflow) nextDate.setDate(0);  // 마지막 날로 조정 ❌

// After: 오버플로우 허용 후 필터링
nextDate.setDate(31);  // 오버플로우 허용
const shouldAdd = nextDate.getDate() === 31;  // 정확히 31일만 ✅
```

**핵심 원칙**:
> 시작 날짜 기준으로 매번 계산, 이전 결과 기준 ❌

### 1028_19: Virtual vs Persistent ID
**핵심 문제**: ⭐ **펼쳐진 이벤트의 임시 ID로 수정 시도**
```
DB: {id: "db-123", date: "2025-01-31", repeat: {type: "monthly"}}
화면: [{id: "temp-1", date: "2025-01-31"}, {id: "temp-2", date: "2025-03-31"}]

사용자: temp-2 수정 → PUT /api/events/temp-2 → 404! ❌
```

**해결**: 메타데이터 추적
```typescript
// 펼칠 때 원본 ID 저장
{
  id: "temp-2",
  repeat: {
    originalEventId: "db-123",  // ⭐ 원본 추적
    originalDate: "2025-01-31"
  }
}

// 수정 시 원본 ID 사용
const updateId = event.repeat?.originalEventId || event.id;
PUT /api/events/db-123  // ✅ 성공!
```

### 1028_20: Server ID Protection
**핵심 문제**: ⭐ **Virtual ID가 서버로 전송되어 원본 ID 덮어씌움**
```
PUT /api/events/db-123
Body: {id: "virtual-temp-456", ...}

서버: {...old, ...body}
→ {id: "virtual-temp-456", ...}  // 원본 ID 손실! ❌
```

**해결**: 이중 방어
```typescript
// 클라이언트: ID 제거
const {id, ...dataWithoutId} = event;
fetch('/api/events/' + persistentId, {
  body: JSON.stringify(dataWithoutId)  // ID 없음!
});

// 서버: ID 무시
const {id: _bodyId, ...body} = req.body;
data[i] = {...old, ...body, id: req.params.id};  // URL ID 사용!
```

### 1028_21: Nested Object Spread
**핵심 문제**: ⭐ **repeat 객체만 제거해야 하는데 id만 제거**
```typescript
// ❌ 문제
const {id, ...eventWithoutId} = event;  // repeat 포함!

const updateData = {
  ...eventWithoutId,  // repeat: {originalEventId, ...} 포함
  repeat: {           // override 시도
    type: newType,
    interval: newInterval
  }
};

// Object spread 순서 문제로 메타데이터 남을 수 있음
```

**해결**: 명시적 제거
```typescript
// ✅ 올바른 방법
const {id, repeat, ...cleanData} = event;  // id와 repeat 모두 제거!

const updateData = {
  ...cleanData,       // repeat 없음!
  repeat: {           // 완전히 새로운 객체
    type: newType,
    interval: newInterval
  }
};
```

### 1028_22: UI Layer Metadata Preservation
**핵심 문제**: ⭐ **App.tsx에서 eventData 생성 시 메타데이터 손실**
```typescript
// ❌ 문제: 폼 데이터로 완전히 새 객체 생성
const eventData = {
  id: editingEvent?.id,  // ID만 복사
  ...formFields,
  repeat: {              // 완전히 새 객체!
    type: formType,      // 메타데이터 손실!
    interval: formInterval
  }
};

// repeat.originalEventId 없음!
→ useEventOperations에서 Virtual ID 사용 → 404 오류
```

**해결**: 조건부 보존
```typescript
// ✅ 올바른 방법
const eventData = editingEvent
  ? {
      ...editingEvent,          // 전체 보존!
      ...formFields,
      repeat: {
        ...editingEvent.repeat,  // 메타데이터 보존!
        type: formType,
        interval: formInterval
      }
    }
  : {
      // 새 이벤트
      ...formFields,
      repeat: {type: formType, interval: formInterval}
    };
```

**3단계 메타데이터 체인**:
```
1. Utils (recurringEventUtils): 펼칠 때 메타데이터 주입
2. UI (App.tsx): 수정 시 메타데이터 보존 ⭐ (여기서 실수!)
3. Hooks (useEventOperations): 저장 시 메타데이터 활용

→ 한 단계라도 끊어지면 전체 실패!
```

## ✅ checklist.md에 추가한 섹션

### 추가한 6가지 치명적 버그 패턴

**Section 5: Implementation vs Integration Gap**
<!-- 구현 vs 통합 격차 -->
- 함수 구현하고 테스트했지만 UI와 통합 안 함
- 체크리스트: 구현 → 테스트 → **통합** → 전체 검증

**Section 6: Date Overflow Filtering**
<!-- 날짜 오버플로우 필터링 -->
- JavaScript Date 자동 조정 문제
- 해결: 조정이 아닌 필터링
- 원칙: 시작점 기준 계산, 이전 결과 기준 ❌

**Section 7: Virtual vs Persistent ID Management**
<!-- 가상 ID vs 영구 ID 관리 -->
- 펼쳐진 데이터의 임시 ID 문제
- 해결: 메타데이터로 원본 추적
- 패턴: originalEventId, originalDate 저장

**Section 8: Nested Object Spread - Metadata Loss**
<!-- 중첩 객체 Spread - 메타데이터 손실 -->
- repeat 객체 재생성 시 메타데이터 손실
- 해결: id와 repeat 모두 명시적 제거
- 규칙: override할 중첩 객체는 spread에서 먼저 제거

**Section 9: UI Layer Metadata Preservation**
<!-- UI 레이어 메타데이터 보존 -->
- 폼 데이터로 새 객체 생성 시 메타데이터 손실
- 해결: editingEvent를 spread 후 폼으로 override
- 3단계 체인: Utils → UI → Hooks

**Section 10: Server ID Protection (Double Defense)**
<!-- 서버 ID 보호 (이중 방어) -->
- Virtual ID가 서버로 전송될 위험
- 해결: 클라이언트 제거 + 서버 무시
- 이중 방어로 안전성 확보

## 📝 각 섹션의 구성

각 버그 패턴마다 다음 구조로 작성:

1. **Problem**: 문제 정의
2. **Bad Example**: 잘못된 코드 예시 (❌)
3. **Good Example**: 올바른 코드 예시 (✅)
4. **Key Principle**: 핵심 원칙
5. **Rule**: 따라야 할 규칙

## 🎯 업데이트된 Key Takeaways

### Coding Standards (기존 유지)
- LF line endings
- Import order
- File ending
- React Hooks dependencies

### Feature Implementation (새로 추가)
- ✅ Implement → Test → **Integrate** → Verify
- ✅ Date calculations: Always from start
- ✅ Expanded data: Track original with metadata
- ✅ Nested object override: Remove from spread first
- ✅ Edit mode: Spread original, then override with form
- ✅ ID protection: Remove at client, ignore at server

### Pre-Commit (업데이트)
- ✅ Run `npm run lint`
- ✅ Run `npm test -- --run` (통합 검증 추가!)
- ✅ Fix CRLF issues immediately

## 💡 핵심 학습 포인트

### 1. 테스트 통과 ≠ 기능 완성
```
구현 ✅ → 테스트 ✅ → 통합 ❌ = 기능 작동 안 함!
```

### 2. 메타데이터 체인의 중요성
```
Utils (주입) → UI (보존) → Hooks (활용)
→ 한 단계라도 누락되면 전체 실패!
```

### 3. Virtual vs Persistent ID 구분
```
Virtual ID: 화면 표시용 (클라이언트 전용)
Persistent ID: DB 저장용 (서버 작업용)
→ 절대 혼용 금지!
```

### 4. Nested Object Spread 주의
```
중첩 객체를 override할 때:
1. 명시적으로 제거
2. 완전히 새로운 객체 생성
3. 메타데이터 보존 필요 시 spread 활용
```

### 5. 이중 방어 패턴
```
클라이언트: 실수 방지 (human error)
서버: 보안 강화 (malicious/buggy clients)
→ 둘 다 구현해야 안전!
```

## ✅ 검증 결과

```
✅ checklist.md 업데이트 완료
✅ 6가지 치명적 버그 패턴 추가
✅ 각 패턴마다 Bad/Good 예시 포함
✅ 핵심 원칙 및 규칙 명시
✅ Lint 오류 0개
✅ 내용 구조화 완료
```

## 📂 파일 위치

**업데이트된 파일**: `src/.cursor/agents/doc/checklist.md`

**새로 추가된 섹션**:
- Line 234-541: "Critical Bug Patterns from Recent Fixes (2025-10-28)"
- Line 543-582: Updated "Key Takeaways"

## 🎉 기대 효과

이제 다음과 같은 오류를 **사전에 방지**할 수 있습니다:

1. ✅ 구현 후 통합 누락
2. ✅ 날짜 오버플로우 잘못 처리
3. ✅ Virtual ID와 Persistent ID 혼용
4. ✅ 중첩 객체 메타데이터 손실
5. ✅ UI 레이어에서 메타데이터 손실
6. ✅ 서버로 Virtual ID 전송

**다음 작업 시 checklist.md 참고하면**:
- 같은 실수 반복 방지
- 코드 리뷰 시 체크포인트
- 신규 개발자 온보딩 가이드
- TDD/구현 패턴 참고 자료

이제 1028_15부터 1028_22까지의 모든 중요한 오류 패턴이 문서화되어, 같은 오류가 재발하지 않도록 방지할 수 있습니다! 📚

