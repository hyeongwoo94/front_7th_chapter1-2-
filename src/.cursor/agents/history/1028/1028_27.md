질문 (원본):
2025-10-28

질문: @# King - 건물주 (Building Owner) 
**구현해
@# Worker - 노동자 (Code Worker)  @# Memory - 세월이 (Time Keeper) @# Memory Home - 세월이집 (Memory's Home) 그리고 history 안에 있는 파일들을 참고하여
@# Worker Home - 노동자집 (Worker's Home)를 리팩토링할거야.
1. agent안에 compny포더를 만들고 이안에 테스트코드를 작성하는 md파일을 하나만들건데 이안에는 단위 테스트를 만드는 내용, 통합 테스트를 만드는 내용이 있어야해. 이때 테스트를 단위테스트를 만들때 어떤 것을 참고했는지 적혀 있어야하고 단위테스트의 기본 형태를 보여주고 결과 형태를 보여줘야하고 해당 작업을 할때의 체크리스트가 적혀 있어야한다.(이파일의 name은 테스트팀원)
2. 다른 파일은 기능 함수를 만든 md파일을 작성할거야. 이안에는 기능 기능함수를 만들때 어떻게 왜 만들게 되었는지 어디에 사용하게될건지 체크리스트를 기준으로 작성해야해.(이파일의 이름은 기능팀원)
 
3. 이 두파일을 만드는 이유는 지금 @# Worker - 노동자 (Code Worker) 가 혼자서 너무 많은 일을 혼자하고 있다. 그래서 노동자를 도와줄 팀원을 만드는거야.

답변:
건물주로서 Worker를 도와줄 전문 팀원들을 성공적으로 만들었습니다!

## 🎯 완료된 작업

### 1. Company 폴더 생성 ✅
```
src/.cursor/agents/company/
├── test-team.md      - 테스트팀원 (Test Specialist)
└── feature-team.md   - 기능팀원 (Feature Specialist)
```

### 2. 테스트팀원 (test-team.md) 생성 ✅

**내용 구성**:

#### 단위 테스트 (Unit Test)
- **무엇인가**: 단일 함수를 독립적으로 테스트
- **참고 자료**:
  - 기존 코드베이스: `src/__tests__/unit/*.spec.ts`
  - Memory Home: 테스트 데이터 구조, 패턴
  - 학습 예시: dateUtils, eventOverlap, timeValidation, recurringEvents
- **기본 구조**:
  ```typescript
  // AAA 패턴
  describe('FunctionName >', () => {
    it('설명', () => {
      // Arrange - 준비
      // Act - 실행
      // Assert - 검증
    });
  });
  ```
- **실제 예시**:
  - Example 1: 간단한 순수 함수 (getDaysInMonth)
  - Example 2: 검증 함수 (getTimeErrorMessage)
  - Example 3: 복잡한 알고리즘 (generateRecurringEvents)
- **결과 형태**:
  - 통과하는 테스트 출력 예시
  - 실패하는 테스트 출력 예시 (Red 단계)
- **체크리스트**:
  - 테스트 작성 전 (요구사항 이해, Memory 확인, 테스트 케이스 식별)
  - 테스트 작성 중 (AAA 패턴, 설명적 이름, 엣지 케이스)
  - 테스트 작성 후 (테스트 실행, 커버리지, 독립성)
  - TDD 전용 (Red-Green-Refactor)

#### 통합 테스트 (Integration Test)
- **무엇인가**: 여러 단위가 함께 작동하는지 테스트
- **참고 자료**:
  - 기존 코드베이스: `src/__tests__/hooks/*.spec.ts`, `src/__tests__/components/*.spec.tsx`
  - 학습 예시: useEventOperations, useCalendarView, Modal, integration
- **기본 구조**:
  - Hook Test Template (renderHook, act)
  - Component Test Template (render, screen, fireEvent)
- **실제 예시**:
  - Example 1: 훅 테스트 (useCalendarView)
  - Example 2: API 모킹이 있는 훅 (useEventOperations)
  - Example 3: 컴포넌트 테스트 (Modal)
  - Example 4: 전체 통합 테스트 (App)
- **체크리스트**:
  - 테스트 작성 전 (통합 지점 식별, 의존성 결정, 사용자 흐름)
  - 테스트 작성 중 (현실적 데이터, 모킹, 비동기 처리)
  - 테스트 작성 후 (독립 실행, 전체 실행, 현실적 시나리오)
  - Hook/Component 전용 체크리스트

**공통 패턴**:
- Assertion 패턴 (toBe, toEqual, toHaveLength 등)
- Mock 패턴 (vi.fn, global.fetch)

### 3. 기능팀원 (feature-team.md) 생성 ✅

**내용 구성**:

#### 함수 구현 철학
- **단일 책임 원칙**: 한 함수는 한 가지 일
- **순수 함수 선호**: 부작용 없음
- **설명적 네이밍**: 동사 + 명사

#### 함수 개발 프로세스 (6단계)
1. **요구사항 이해**: 문제 정의, 입력/출력, 엣지 케이스
2. **함수 시그니처 설계**: 이름, 타입, 기본값, JSDoc
3. **구현 전략 계획**: 알고리즘, 헬퍼 함수, 엣지 케이스
4. **TDD로 구현**: Red → Green → Refactor
5. **문서화 추가**: JSDoc, 매개변수, 반환값, 예시
6. **사용 위치 고려**: 어디서 호출될지, 통합 방법

#### 실제 구현 예시
**Example 1: Date Utility Functions**
- **How (어떻게)**: getDaysInMonth, getWeekDates, formatMonth 구현
- **Why (왜)**: 재사용성, 추상화, 테스트 가능성, 일관성
- **Where (어디에)**: useCalendarView, App.tsx, Event Display

**Example 2: Validation Functions**
- **How**: getTimeErrorMessage 구현
- **Why**: 사용자 입력 검증, 명확한 오류 메시지, 분리, 타입 지정된 결과
- **Where**: useEventForm, Form UI

**Example 3: Event Overlap Detection**
- **How**: isOverlapping, findOverlappingEvents 구현
- **Why**: 비즈니스 규칙, 알고리즘 복잡성, 재사용성
- **Where**: Event Creation/Update, Real-time Validation, Event List Display

#### 체크리스트 (5단계)
1. **Planning Phase**: 요구사항, Memory, 입출력, 엣지 케이스, 사용 계획
2. **Design Phase**: 함수 이름, 타입, 반환값, 기본값, 단일 책임
3. **Implementation Phase**: 테스트로 시작, 최소 코드, 엣지 케이스, 순수 함수, 오류 처리
4. **Documentation Phase**: JSDoc, 예시, 엣지 케이스 참고, 인라인 주석
5. **Integration Phase**: Import, 올바른 호출, 반환값 사용, 오류 처리, 통합 테스트
6. **Quality Phase**: 테스트 통과, Lint, 코드 리뷰, 성능, 메모리

#### Memory에서 학습
- **교훈 1**: 반복 횟수 기반 vs 점진적 계산
- **교훈 2**: 메타데이터 보존
- **교훈 3**: 필터 vs 조정 철학

### 4. Worker Home (toolsHome.md) 리팩토링 ✅

**변경 사항**:

**Before (이전)**:
```
Worker가 혼자서:
- 테스트 작성
- 함수 구현
- 훅 작성
- 컴포넌트 작성
- 통합
```

**After (이후)**:
```
Worker는 팀 Orchestrator:
├── Test Team에 테스트 작성 위임
├── Feature Team에 함수 구현 위임
├── 두 팀을 조율
└── 통합 및 품질 관리
```

**새로운 내용**:

1. **Worker의 새로운 역할**: Orchestrator
   - 작업 받기 → 위임 → 조율 → 통합 → 전달

2. **팀 구조**:
   ```
   Worker (Orchestrator)
   ├── Test Team (테스트 전문가)
   └── Feature Team (기능 전문가)
   ```

3. **조율 워크플로 (6단계)**:
   - Step 1: King/Planner로부터 작업 받기
   - Step 2: Test Team에 위임 (Red Phase)
   - Step 3: Feature Team에 위임 (Green Phase)
   - Step 4: 리팩토링 조율
   - Step 5: 통합
   - Step 6: Manager에게 전달

4. **팀원 조율 패턴**:
   - Pattern 1: 간단한 함수 구현
   - Pattern 2: 엣지 케이스가 있는 복잡한 기능
   - Pattern 3: UI 컴포넌트

5. **커뮤니케이션 프로토콜**:
   - Worker → Test Team
   - Worker → Feature Team
   - Worker → Manager

### 5. Worker 역할 파일 (tools.md) 업데이트 ✅

**변경사항**:
- **role**: "code worker & team orchestrator"로 업데이트
<!-- 역할: "코드 노동자 & 팀 오케스트레이터" -->
- **description**: 전문 팀원들을 조율하여 고품질 코드 제공
<!-- 설명: 전문 팀원들을 조율하여 고품질 코드 제공 -->

**새로운 Responsibilities**:
1. **Orchestration Responsibilities** (조율 책임)
   - 작업 분석
   - 팀 조율
   - TDD 조율
   - 통합 관리
   - 품질 보증

2. **Technical Responsibilities** (기술 책임)
   - 코드 통합
   - 아키텍처 결정
   - 엔드투엔드 검증
   - 문서화 검토
   - 산출물 준비

3. **Team Member Management** (팀원 관리)
   - Test Team 지시
   - Feature Team 지시
   - 진행 추적
   - 품질 기준

**업데이트된 Integration Points**:
- Test Team (테스트팀원) 연동 포인트 추가
- Feature Team (기능팀원) 연동 포인트 추가
- 각 팀원 파일 참조 경로 포함

## 📊 시스템 개선 효과

### Before (이전)
```
❌ Worker 혼자 모든 것 처리
❌ 압도적인 작업량
❌ 테스트와 구현 간 컨텍스트 전환
❌ 통합 단계 누락 위험
❌ 모든 측면에서 품질 유지 어려움
```

### After (이후)
```
✅ 전문화된 팀원들
✅ 명확한 책임 분리
✅ Test Team → 포괄적인 테스트 커버리지
✅ Feature Team → 깔끔한 구현
✅ Worker → 통합과 품질 보장
✅ 더 나은 업무 분담
```

## 🎯 팀원별 역할 명확화

### Test Team (테스트팀원)
**전문성**: 테스트 코드 작성
**책임**:
- 단위 테스트 작성
- 통합 테스트 작성
- 테스트 커버리지 보장
- TDD Red 단계

**도구**:
- `test-team.md` 가이드라인
- Memory의 테스트 패턴
- 기존 테스트 예시

### Feature Team (기능팀원)
**전문성**: 기능 함수 구현
**책임**:
- 유틸리티 함수 구현
- 비즈니스 로직 구현
- 알고리즘 구현
- TDD Green 단계

**도구**:
- `feature-team.md` 가이드라인
- Memory의 코드 패턴
- 구현 철학

### Worker (노동자)
**전문성**: 팀 조율 및 통합
**책임**:
- 작업 분석 및 위임
- TDD 사이클 조율
- 코드 통합
- 품질 보증
- Manager에게 전달

**도구**:
- `toolsHome.md` 조율 가이드
- 두 팀원의 산출물
- Memory의 통합 패턴

## 💡 실제 작업 흐름 예시

### 예시: "반복 일정 생성 기능 구현"

**1. Worker 작업 분석**:
```
- 유틸리티 함수 필요 (Feature Team)
- 복잡한 알고리즘 (포괄적 테스트 필요)
- 엣지 케이스 많음 (31일, 윤년)
```

**2. Test Team 작업** (Red):
```
- generateRecurringEvents 테스트 16개 작성
- 매일/매주/매월/매년 패턴
- 31일 엣지 케이스
- 윤년 처리
→ 모든 테스트 실패 (Red ✅)
```

**3. Feature Team 작업** (Green):
```
- generateRecurringEvents 함수 구현
- 반복 횟수 기반 계산 (Memory 참고)
- 오버플로우 필터링 (Memory 참고)
- JSDoc 문서화
→ 16개 테스트 모두 통과 (Green ✅)
```

**4. Worker 통합**:
```
- useEventOperations에 import
- saveEvent에서 호출
- fetchEvents에서 확장
→ 엔드투엔드 작동 (Integration ✅)
```

**5. Manager 검토**:
```
- 코드 품질: ✅
- 테스트 커버리지: ✅
- 통합: ✅
- 문서화: ✅
→ 승인!
```

## 🎓 핵심 개선 사항

### 1. 전문화 (Specialization)
- 각 팀원이 자신의 전문 분야에만 집중
- 더 높은 품질의 산출물

### 2. 명확한 책임 (Clear Responsibilities)
- Worker: 조율 및 통합
- Test Team: 테스트
- Feature Team: 구현

### 3. 체계적인 프로세스 (Systematic Process)
- 명확한 워크플로 (6단계)
- 커뮤니케이션 프로토콜
- 품질 체크리스트

### 4. 학습 기반 (Learning-Based)
- Memory의 과거 패턴 활용
- 실제 프로젝트 예시 참조
- 반복되는 실수 방지

### 5. 확장 가능성 (Scalability)
- 미래에 더 많은 팀원 추가 가능
- Hook Team, Component Team 등
- Worker는 순수 조율자로 진화

## ✅ 검증 결과

```
✅ company/ 폴더 생성
✅ test-team.md 작성 (포괄적인 테스트 가이드)
✅ feature-team.md 작성 (함수 구현 가이드)
✅ toolsHome.md 리팩토링 (조율 허브)
✅ tools.md 업데이트 (새로운 역할)
✅ 실제 프로젝트 패턴 반영
✅ Memory 학습 내용 통합
✅ 체크리스트 포함
✅ 실제 예시 다수 포함
```

## 📂 파일 위치

```
src/.cursor/agents/
├── company/                    ← NEW!
│   ├── test-team.md           ← 테스트팀원 가이드
│   └── feature-team.md        ← 기능팀원 가이드
├── home/
│   └── toolsHome.md           ← REFACTORED (조율 허브)
└── people/
    └── tools.md               ← UPDATED (새로운 역할)
```

## 🎉 결론

Worker는 이제 더 이상 혼자가 아닙니다!

**전문화된 팀원들**:
- 테스트팀원: 테스트의 달인
- 기능팀원: 구현의 달인
- Worker: 조율의 달인

**시너지 효과**:
- 더 높은 코드 품질
- 더 빠른 개발 속도
- 더 적은 실수
- 더 나은 협업

**AI 에이전트 시스템 발전**:
```
Phase 1: Worker Solo          → 작동하지만 부담됨
Phase 2: Worker + 2 Team Members → 현재 (효율적)
Phase 3: 미래 확장           → 더 많은 전문 팀원
```

Worker를 도와줄 강력한 팀이 구성되었습니다! 🚀

