질문 (원본):
2025-10-28

질문: **학습해** 현재 31일을 선택하고 매월 반복으로 누르면 매 각월의 마지막에 나타난다. 이것이 아닌 각 매월의 31일에 표시하고 싶다. 만약 31일이 없는 월이라면 해당 월에는 표시를 안하는게 맞다.
또 2월 29일로 등록했다면 윤년 2월 29일에만 표시가 되어야 한다.

답변:
건물주로서 매월/매년 반복 일정의 날짜 처리 로직을 수정했습니다.

## 🔍 문제 분석

### 기존 동작 (잘못됨)
```
31일 반복 일정 등록:
❌ 1월 31일 → 2월 28일 (마지막 날로 대체)
❌ 2월 28일 → 3월 31일 
❌ 3월 31일 → 4월 30일 (마지막 날로 대체)
```

**문제점**: 
- 31일이 없는 월에 해당 월의 마지막 날(28일, 30일)로 표시됨
- 사용자가 원하는 동작이 아님

### 요구사항 (올바른 동작)
```
31일 반복 일정 등록:
✅ 1월 31일 → 표시
✅ 2월 → 건너뜀 (31일 없음)
✅ 3월 31일 → 표시
✅ 4월 → 건너뜀 (31일 없음)
✅ 5월 31일 → 표시

2월 29일 반복 일정 등록:
✅ 2024년 2월 29일 → 표시 (윤년)
✅ 2025년 → 건너뜀 (평년)
✅ 2026년 → 건너뜀 (평년)
✅ 2027년 → 건너뜀 (평년)
✅ 2028년 2월 29일 → 표시 (윤년)
```

## ✅ 적용한 수정

### 1. 핵심 전략 변경

**Before (오버플로우 후 마지막 날로 조정)**:
```typescript
nextDate.setDate(originalDay); // 31일 시도
if (nextDate.getMonth() !== targetMonth) {
  nextDate.setDate(0); // 오버플로우 발생 시 마지막 날로 설정 ❌
}
```

**After (오버플로우 시 필터링)**:
```typescript
// 1. 일단 모든 달에 원래 날짜 설정 시도
nextDate.setDate(originalDay);

// 2. 날짜가 일치하는 경우에만 이벤트 추가
const shouldAddEvent = currentDate.getDate() === originalDay;
```

### 2. 반복 횟수 추적 방식 변경

**문제**: 오버플로우된 날짜를 기준으로 다음 달을 계산하면 잘못된 결과 발생

**디버깅 결과**:
```
Start: 2025-01-31
0: 2025-01-31, Day: 31 ✅
1: 2025-03-03, Day: 3  ❌ (2월 31일 → 3월 3일로 오버플로우)
2: 2025-05-01, Day: 1  ❌ (3월 3일 + 1개월 = 4월 3일 → 5월 1일로 계산)
```

**해결**: 반복 횟수를 별도로 추적하고, 항상 startDate를 기준으로 계산

```typescript
// Before: currentDate를 기준으로 다음 달 계산 (오류 발생)
currentDate = getNextOccurrence(currentDate, startDate, 'monthly', 1);

// After: 반복 횟수를 기준으로 startDate에서 계산
currentDate = getMonthlyOccurrence(startDate, iterationCount, interval);
```

### 3. 새로운 헬퍼 함수 추가

**파일**: `src/utils/recurringEventUtils.ts`

#### getMonthlyOccurrence
```typescript
function getMonthlyOccurrence(startDate: Date, iteration: number, interval: number): Date {
  const result = new Date(startDate);
  const originalDay = startDate.getDate();

  // Calculate target month and year
  const monthsToAdd = iteration * interval;
  const targetMonth = (startDate.getMonth() + monthsToAdd) % 12;
  const targetYear =
    startDate.getFullYear() + Math.floor((startDate.getMonth() + monthsToAdd) / 12);

  // Set to 1st day first, then target month/year, then try original day
  result.setDate(1);
  result.setFullYear(targetYear);
  result.setMonth(targetMonth);
  result.setDate(originalDay); // 오버플로우 허용 (필터링으로 처리)

  return result;
}
```

**특징**:
- 항상 `startDate`를 기준으로 계산
- `iteration` 번째 발생 시점을 직접 계산
- 오버플로우는 상위 함수에서 필터링

#### getYearlyOccurrence
```typescript
function getYearlyOccurrence(startDate: Date, iteration: number, interval: number): Date {
  const result = new Date(startDate);
  const originalDay = startDate.getDate();
  const originalMonth = startDate.getMonth();

  // Calculate target year
  const targetYear = startDate.getFullYear() + iteration * interval;

  // Set to 1st day first, then target year, then try original month and day
  result.setDate(1);
  result.setFullYear(targetYear);
  result.setMonth(originalMonth);
  result.setDate(originalDay); // 오버플로우 허용 (필터링으로 처리)

  return result;
}
```

### 4. generateRecurringEvents 수정

```typescript
export function generateRecurringEvents(event: Event, maxOccurrences = 365): Event[] {
  // ...
  const originalDay = startDate.getDate();
  let iterationCount = 0;
  const maxIterations = maxOccurrences * 12; // 건너뛴 달 때문에 더 많은 반복 필요

  while (events.length < maxOccurrences && iterationCount < maxIterations) {
    let currentDate: Date;

    // Calculate date based on iteration count
    if (event.repeat.type === 'monthly') {
      currentDate = getMonthlyOccurrence(startDate, iterationCount, event.repeat.interval);
    } else if (event.repeat.type === 'yearly') {
      currentDate = getYearlyOccurrence(startDate, iterationCount, event.repeat.interval);
    } else {
      // Daily/Weekly는 기존 방식 사용
      currentDate =
        iterationCount === 0
          ? new Date(startDate)
          : getNextOccurrence(
              events[events.length - 1].date,
              startDate,
              event.repeat.type,
              event.repeat.interval
            );
    }

    // ⭐ 핵심: 날짜가 원래 날짜와 일치할 때만 이벤트 추가
    const shouldAddEvent =
      event.repeat.type === 'daily' ||
      event.repeat.type === 'weekly' ||
      currentDate.getDate() === originalDay;

    if (shouldAddEvent) {
      const dateString = formatDate(currentDate);

      if (endDate && dateString > formatDate(endDate)) {
        break;
      }

      events.push({
        ...event,
        id: generateEventId(),
        date: dateString,
        repeat: {
          ...event.repeat,
          id: repeatId,
        },
      });
    }

    iterationCount++;
  }

  return events;
}
```

**핵심 로직**:
1. **반복 횟수 기준 계산**: 오버플로우 문제 방지
2. **날짜 일치 검증**: `currentDate.getDate() === originalDay`
3. **필터링**: 일치하지 않으면 이벤트 추가 안 함

## 🧪 테스트 수정

### 테스트 설명 변경

**Before**:
```typescript
it('매월 31일 반복 일정이 31일이 없는 달에는 해당 달의 마지막 날로 생성한다', () => {
  // ...
  expect(result[1].date).toBe('2025-02-28'); // 2월은 28일까지
  expect(result[3].date).toBe('2025-04-30'); // 4월은 30일까지
});
```

**After**:
```typescript
it('매월 31일 반복 일정이 31일이 없는 달에는 건너뛴다', () => {
  const event = {
    ...baseEvent,
    date: '2025-01-31',
    repeat: { type: 'monthly', interval: 1, endDate: '2025-08-31' },
  };

  const result = generateRecurringEvents(event);

  // 31일이 있는 달만: 1월, 3월, 5월, 7월, 8월
  // 2월(28일), 4월(30일), 6월(30일)은 건너뜀
  expect(result).toHaveLength(5);
  expect(result[0].date).toBe('2025-01-31');
  expect(result[1].date).toBe('2025-03-31');
  expect(result[2].date).toBe('2025-05-31');
  expect(result[3].date).toBe('2025-07-31');
  expect(result[4].date).toBe('2025-08-31');
});
```

### 윤년 테스트 변경

**Before**:
```typescript
it('매년 2월 29일 반복 일정이 윤년이 아닌 해에는 2월 28일로 생성한다', () => {
  // ...
  expect(result[1].date).toBe('2025-02-28'); // 평년 → 28일로 조정
});
```

**After**:
```typescript
it('매년 2월 29일 반복 일정이 윤년에만 생성된다', () => {
  const event = {
    ...baseEvent,
    date: '2024-02-29', // 윤년
    repeat: { type: 'yearly', interval: 1, endDate: '2032-02-29' },
  };

  const result = generateRecurringEvents(event);

  // 윤년에만 2월 29일이 존재: 2024, 2028, 2032
  // 평년 (2025, 2026, 2027, 2029, 2030, 2031)은 건너뜀
  expect(result).toHaveLength(3);
  expect(result[0].date).toBe('2024-02-29'); // 윤년
  expect(result[1].date).toBe('2028-02-29'); // 윤년
  expect(result[2].date).toBe('2032-02-29'); // 윤년
});
```

## 📊 테스트 결과

```
✅ 매일 반복 > 매일 반복 일정을 생성한다
✅ 매일 반복 > 매일 반복 일정을  2일 간격으로 생성한다
✅ 매일 반복 > 종료일이 없으면 최대 365일까지 생성한다
✅ 매주 반복 > 매주 반복 일정을 생성한다
✅ 매주 반복 > 매주 반복 일정을 2주 간격으로 생성한다
✅ 매월 반복 > 매월 반복 일정을 생성한다
✅ 매월 반복 > 매월 반복 일정을 2개월 간격으로 생성한다
✅ 매월 반복 > 매월 31일 반복 일정이 31일이 없는 달에는 건너뛴다 ⭐
✅ 매월 반복 > 매월 31일 반복 일정이 윤년의 2월을 건너뛴다 ⭐
✅ 매년 반복 > 매년 반복 일정을 생성한다
✅ 매년 반복 > 매년 반복 일정을 2년 간격으로 생성한다
✅ 매년 반복 > 매년 2월 29일 반복 일정이 윤년에만 생성된다 ⭐
✅ 반복 없음 > 반복 유형이 none이면 원본 일정만 반환한다
✅ 반복 일정 속성 > 생성된 모든 반복 일정이 원본 일정의 속성을 유지한다
✅ 반복 일정 속성 > 생성된 모든 반복 일정이 고유한 id를 가진다
✅ 반복 일정 속성 > 생성된 모든 반복 일정이 동일한 repeat.id를 가진다

Test Files: 1 passed
Tests: 16 passed
```

## 🎯 동작 예시

### 예시 1: 31일 반복 (1년간)

**입력**:
- 시작일: 2025-01-31
- 반복 유형: 매월
- 종료일: 2025-12-31

**결과**:
```
✅ 2025-01-31 (1월 - 31일 있음)
❌ 2025-02-XX (2월 - 31일 없음, 건너뜀)
✅ 2025-03-31 (3월 - 31일 있음)
❌ 2025-04-XX (4월 - 31일 없음, 건너뜀)
✅ 2025-05-31 (5월 - 31일 있음)
❌ 2025-06-XX (6월 - 31일 없음, 건너뜀)
✅ 2025-07-31 (7월 - 31일 있음)
✅ 2025-08-31 (8월 - 31일 있음)
❌ 2025-09-XX (9월 - 31일 없음, 건너뜀)
✅ 2025-10-31 (10월 - 31일 있음)
❌ 2025-11-XX (11월 - 31일 없음, 건너뜀)
✅ 2025-12-31 (12월 - 31일 있음)

총 7개 이벤트 생성
```

### 예시 2: 2월 29일 반복 (8년간)

**입력**:
- 시작일: 2024-02-29 (윤년)
- 반복 유형: 매년
- 종료일: 2032-02-29

**결과**:
```
✅ 2024-02-29 (윤년)
❌ 2025-XX-XX (평년, 건너뜀)
❌ 2026-XX-XX (평년, 건너뜀)
❌ 2027-XX-XX (평년, 건너뜀)
✅ 2028-02-29 (윤년)
❌ 2029-XX-XX (평년, 건너뜀)
❌ 2030-XX-XX (평년, 건너뜀)
❌ 2031-XX-XX (평년, 건너뜀)
✅ 2032-02-29 (윤년)

총 3개 이벤트 생성
```

### 예시 3: 30일 반복

**입력**:
- 시작일: 2025-01-30
- 반복 유형: 매월

**결과**:
```
✅ 2025-01-30 (1월)
❌ 2025-02-XX (2월 - 30일 없음, 건너뜀)
✅ 2025-03-30 (3월)
✅ 2025-04-30 (4월)
✅ 2025-05-30 (5월)
✅ 2025-06-30 (6월)
✅ 2025-07-30 (7월)
... 계속

총 11개 이벤트 생성 (2월 제외)
```

## 💡 학습 포인트

### 1. Date 오버플로우 처리 전략

**문제**: JavaScript Date 객체는 오버플로우를 자동으로 처리
```javascript
const date = new Date('2025-02-01');
date.setDate(31); // 2025-03-03으로 오버플로우
```

**해결 방법 A (기존)**: 오버플로우 감지 후 조정
```javascript
nextDate.setDate(originalDay);
if (nextDate.getMonth() !== targetMonth) {
  nextDate.setDate(0); // 마지막 날로 설정
}
```

**해결 방법 B (새로운 방식)**: 오버플로우 허용 후 필터링
```javascript
nextDate.setDate(originalDay);
// 나중에 날짜 일치 여부로 필터링
const shouldAddEvent = currentDate.getDate() === originalDay;
```

**장점**:
- 더 명확한 의도 표현
- 사용자 요구사항과 일치
- 테스트 작성이 더 쉬움

### 2. 반복 계산 시 기준점의 중요성

**잘못된 방법**: 이전 결과를 기준으로 다음 계산
```javascript
// ❌ 오버플로우가 누적됨
currentDate = getNextOccurrence(currentDate, ...);
```

**올바른 방법**: 시작점을 기준으로 매번 재계산
```javascript
// ✅ 오류가 누적되지 않음
currentDate = getMonthlyOccurrence(startDate, iterationCount, interval);
```

### 3. 무한 루프 방지

**문제**: 건너뛴 달이 많을 경우 필요한 반복 횟수 증가

**해결**:
```typescript
const maxIterations = maxOccurrences * 12; // 12배 여유
while (events.length < maxOccurrences && iterationCount < maxIterations) {
  // ...
}
```

## ✅ 최종 확인

```
✅ 로직 수정 완료
✅ 테스트 16개 모두 통과
✅ Lint 오류 0개
✅ 사용자 요구사항 충족:
   - 31일 반복 → 31일 있는 달에만 표시
   - 2월 29일 반복 → 윤년에만 표시
✅ 기존 기능 유지 (일일/주간 반복)
```

이제 사용자님이 31일 반복 일정을 등록하면:
- 31일이 있는 달: 1월, 3월, 5월, 7월, 8월, 10월, 12월에만 표시 ✅
- 31일이 없는 달: 2월, 4월, 6월, 9월, 11월은 건너뜀 ✅

2월 29일 반복 일정을 등록하면:
- 윤년: 2024, 2028, 2032...에만 표시 ✅
- 평년: 건너뜀 ✅

