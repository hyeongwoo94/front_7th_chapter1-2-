질문 (원본):
2025-10-28

질문: @# King - 건물주 (Building Owner) 
**구현해** 테스트코드를 작성해줘.
반복유형을 선택했다면 매일,매주,매월,매년에에 반복등록되기위해 테스트해야하는 것을 
describe은 반복일정으로지정한고 그안에 it('설명',() =>{}) 같은 방식으로 테스트해야하는 것들을 만들어줘.

답변:
건물주로서 반복 일정 기능의 테스트 코드를 TDD 방식으로 작성 완료했습니다.

## ✅ TDD 사이클 완료: Red → Green → Refactor

### Red 단계 (테스트 작성)

**파일**: `src/__tests__/unit/medium.recurringEvents.spec.ts`

**테스트 구조**:
```typescript
describe('반복일정 >', () => {
  describe('매일 반복', () => { ... })
  describe('매주 반복', () => { ... })
  describe('매월 반복', () => { ... })
  describe('매년 반복', () => { ... })
  describe('반복 없음', () => { ... })
  describe('반복 일정 속성', () => { ... })
});
```

**작성한 테스트 케이스** (총 16개):

#### 1. 매일 반복 (3개)
- ✅ 매일 반복 일정을 생성한다
- ✅ 매일 반복 일정을 2일 간격으로 생성한다
- ✅ 종료일이 없으면 최대 365일까지 생성한다

#### 2. 매주 반복 (2개)
- ✅ 매주 반복 일정을 생성한다
- ✅ 매주 반복 일정을 2주 간격으로 생성한다

#### 3. 매월 반복 (4개)
- ✅ 매월 반복 일정을 생성한다
- ✅ 매월 반복 일정을 2개월 간격으로 생성한다
- ✅ 매월 31일 반복 일정이 31일이 없는 달에는 해당 달의 마지막 날로 생성한다
- ✅ 매월 반복 일정이 윤년의 2월을 올바르게 처리한다

#### 4. 매년 반복 (3개)
- ✅ 매년 반복 일정을 생성한다
- ✅ 매년 반복 일정을 2년 간격으로 생성한다
- ✅ 매년 2월 29일 반복 일정이 윤년이 아닌 해에는 2월 28일로 생성한다

#### 5. 반복 없음 (1개)
- ✅ 반복 유형이 none이면 원본 일정만 반환한다

#### 6. 반복 일정 속성 (3개)
- ✅ 생성된 모든 반복 일정이 원본 일정의 속성을 유지한다
- ✅ 생성된 모든 반복 일정이 고유한 id를 가진다
- ✅ 생성된 모든 반복 일정이 동일한 repeat.id를 가진다

### Green 단계 (구현)

**파일**: `src/utils/recurringEventUtils.ts`

**구현한 함수**:

#### 1. `generateRecurringEvents(event, maxOccurrences)`
반복 설정에 따라 반복 일정 배열을 생성하는 메인 함수

```typescript
export function generateRecurringEvents(event: Event, maxOccurrences = 365): Event[] {
  if (event.repeat.type === 'none') {
    return [event];
  }

  const events: Event[] = [];
  const startDate = new Date(event.date);
  const endDate = event.repeat.endDate ? new Date(event.repeat.endDate) : null;
  const repeatId = event.repeat.id || generateRepeatId();

  let currentDate = new Date(startDate);
  let occurrenceCount = 0;

  while (occurrenceCount < maxOccurrences) {
    if (endDate && currentDate > endDate) {
      break;
    }

    events.push({
      ...event,
      id: generateEventId(),
      date: formatDate(currentDate),
      repeat: {
        ...event.repeat,
        id: repeatId,
      },
    });

    occurrenceCount++;
    currentDate = getNextOccurrence(
      currentDate,
      startDate,
      event.repeat.type,
      event.repeat.interval
    );
  }

  return events;
}
```

#### 2. `getNextOccurrence(currentDate, startDate, type, interval)`
반복 유형에 따라 다음 발생 날짜를 계산

**주요 로직**:

**매일 (daily)**:
```typescript
nextDate.setDate(nextDate.getDate() + interval);
```

**매주 (weekly)**:
```typescript
nextDate.setDate(nextDate.getDate() + interval * 7);
```

**매월 (monthly)** - 월말 날짜 처리:
```typescript
// 1. 목표 월 계산
const targetMonth = (currentDate.getMonth() + interval) % 12;
const targetYear = currentDate.getFullYear() + Math.floor((currentDate.getMonth() + interval) / 12);

// 2. 날짜를 1일로 설정하여 오버플로우 방지
nextDate.setDate(1);
nextDate.setFullYear(targetYear);
nextDate.setMonth(targetMonth);

// 3. 원래 날짜로 설정 시도
nextDate.setDate(originalDay);

// 4. 월이 변경되었으면 (오버플로우) 해당 월의 마지막 날로 설정
if (nextDate.getMonth() !== targetMonth) {
  nextDate.setDate(0);
}
```

**매년 (yearly)** - 윤년 처리:
```typescript
const targetYear = currentDate.getFullYear() + interval;
const targetMonth = startDate.getMonth();

nextDate.setDate(1);
nextDate.setFullYear(targetYear);
nextDate.setMonth(targetMonth);
nextDate.setDate(originalDay);

if (nextDate.getMonth() !== targetMonth) {
  nextDate.setDate(0);
}
```

#### 3. 헬퍼 함수들
- `formatDate(date)`: YYYY-MM-DD 형식으로 포맷
- `generateRepeatId()`: 반복 시리즈 고유 ID 생성
- `generateEventId()`: 개별 일정 고유 ID 생성

### 타입 업데이트

**파일**: `src/types.ts`

```typescript
export interface RepeatInfo {
  type: RepeatType;
  interval: number;
  endDate?: string;
  id?: string;  // ⭐ 추가: 반복 시리즈 식별자
}
```

## 🎯 엣지 케이스 처리

### 1. 월말 날짜 처리
**문제**: 1월 31일 → 2월로 이동하면?
**해결**: 2월에 31일이 없으므로 2월 28일(또는 29일)로 설정

**테스트 케이스**:
```typescript
// 1월 31일 → 2월 28일 → 3월 31일 → 4월 30일
expect(result[0].date).toBe('2025-01-31');
expect(result[1].date).toBe('2025-02-28'); // 2월은 28일까지
expect(result[2].date).toBe('2025-03-31');
expect(result[3].date).toBe('2025-04-30'); // 4월은 30일까지
```

### 2. 윤년 처리
**문제**: 2024년 1월 31일 → 2월은 윤년이므로 29일까지
**해결**: 윤년 2월은 29일로 설정

**테스트 케이스**:
```typescript
expect(result[0].date).toBe('2024-01-31');
expect(result[1].date).toBe('2024-02-29'); // 2024년은 윤년
expect(result[2].date).toBe('2024-03-31');
```

### 3. 2월 29일 매년 반복
**문제**: 2024년 2월 29일 → 2025년은 평년이므로 2월 29일 없음
**해결**: 평년에는 2월 28일로 설정

**테스트 케이스**:
```typescript
expect(result[0].date).toBe('2024-02-29'); // 윤년
expect(result[1].date).toBe('2025-02-28'); // 평년
expect(result[2].date).toBe('2026-02-28'); // 평년
expect(result[3].date).toBe('2027-02-28'); // 평년
expect(result[4].date).toBe('2028-02-29'); // 윤년
```

## 🔧 구현 과정에서 해결한 문제들

### 문제 1: 월말 날짜 오버플로우
**초기 문제**:
```typescript
nextDate.setMonth(nextDate.getMonth() + interval);
nextDate.setDate(originalDay);
```
→ 2월 31일이 되려고 하면 3월 3일이 되고, 그 상태에서 setDate(31)을 하면 3월 31일이 됨

**해결**:
```typescript
nextDate.setDate(1);  // 먼저 1일로 설정
nextDate.setMonth(targetMonth);
nextDate.setDate(originalDay);  // 그 다음 원래 날짜로
if (nextDate.getMonth() !== targetMonth) {
  nextDate.setDate(0);  // 오버플로우 시 이전 달 마지막 날
}
```

### 문제 2: 원래 시작 날짜 추적
**초기 문제**: 현재 날짜만 보고 다음 날짜 계산 → 2월 28일에서 3월로 가면 3월 28일이 됨 (31일로 돌아가지 않음)

**해결**: `getNextOccurrence`에 `startDate` 전달하여 원래 날짜 기억

## 📊 테스트 결과

```
✓ src/__tests__/unit/medium.recurringEvents.spec.ts (16 tests) 9ms
  ✓ 반복일정 > > 매일 반복 > 매일 반복 일정을 생성한다
  ✓ 반복일정 > > 매일 반복 > 매일 반복 일정을 2일 간격으로 생성한다
  ✓ 반복일정 > > 매일 반복 > 종료일이 없으면 최대 365일까지 생성한다
  ✓ 반복일정 > > 매주 반복 > 매주 반복 일정을 생성한다
  ✓ 반복일정 > > 매주 반복 > 매주 반복 일정을 2주 간격으로 생성한다
  ✓ 반복일정 > > 매월 반복 > 매월 반복 일정을 생성한다
  ✓ 반복일정 > > 매월 반복 > 매월 반복 일정을 2개월 간격으로 생성한다
  ✓ 반복일정 > > 매월 반복 > 매월 31일 반복 일정이 31일이 없는 달에는 해당 달의 마지막 날로 생성한다
  ✓ 반복일정 > > 매월 반복 > 매월 반복 일정이 윤년의 2월을 올바르게 처리한다
  ✓ 반복일정 > > 매년 반복 > 매년 반복 일정을 생성한다
  ✓ 반복일정 > > 매년 반복 > 매년 반복 일정을 2년 간격으로 생성한다
  ✓ 반복일정 > > 매년 반복 > 매년 2월 29일 반복 일정이 윤년이 아닌 해에는 2월 28일로 생성한다
  ✓ 반복일정 > > 반복 없음 > 반복 유형이 none이면 원본 일정만 반환한다
  ✓ 반복일정 > > 반복 일정 속성 > 생성된 모든 반복 일정이 원본 일정의 속성을 유지한다
  ✓ 반복일정 > > 반복 일정 속성 > 생성된 모든 반복 일정이 고유한 id를 가진다
  ✓ 반복일정 > > 반복 일정 속성 > 생성된 모든 반복 일정이 동일한 repeat.id를 가진다

Test Files  1 passed (1)
Tests  16 passed (16)
```

## 🎉 완료 사항

✅ **파일 생성**:
- `src/__tests__/unit/medium.recurringEvents.spec.ts` - 반복 일정 테스트
- `src/utils/recurringEventUtils.ts` - 반복 일정 유틸 함수

✅ **타입 업데이트**:
- `src/types.ts` - `RepeatInfo`에 `id?: string` 추가

✅ **테스트 커버리지**:
- 매일/매주/매월/매년 반복 모든 패턴 ✅
- 간격(interval) 처리 ✅
- 종료일 처리 ✅
- 월말 날짜 처리 ✅
- 윤년 처리 ✅
- 반복 ID 관리 ✅
- 속성 유지 검증 ✅

✅ **TDD 원칙 준수**:
- Red: 실패하는 테스트 먼저 작성 ✅
- Green: 테스트 통과하는 최소 코드 구현 ✅
- 모든 테스트 통과 (16/16) ✅

## 💡 사용 예시

```typescript
import { generateRecurringEvents } from './utils/recurringEventUtils';

const event: Event = {
  id: '1',
  title: '팀 회의',
  date: '2025-01-01',
  startTime: '10:00',
  endTime: '11:00',
  description: '주간 팀 미팅',
  location: '회의실 A',
  category: '업무',
  repeat: {
    type: 'weekly',
    interval: 1,
    endDate: '2025-01-29',
  },
  notificationTime: 10,
};

const recurringEvents = generateRecurringEvents(event);
// Returns: 5개의 일정 (1/1, 1/8, 1/15, 1/22, 1/29)
```

이제 반복 일정 기능이 완벽하게 구현되고 테스트되었습니다! 🚀

